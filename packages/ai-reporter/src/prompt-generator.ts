/**
 * AI Prompt Generator
 * Generates markdown prompts for coding AIs to fix code duplications
 */

import { AIEnhancedClone, AIReport } from './index';
import { writeFileSync } from 'fs-extra';

export interface PromptGeneratorOptions {
  outputPath: string;
  projectName?: string;
  language?: string;
}

export class PromptGenerator {
  private options: PromptGeneratorOptions;

  constructor(options: PromptGeneratorOptions) {
    this.options = options;
  }

  /**
   * Generates markdown prompt from AI report
   */
  public generatePrompt(report: AIReport): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateHeader(report));

    // Summary section
    sections.push(this.generateSummary(report));

    // High priority tasks
    const highPriority = this.filterByPriority(report.clones, 'high');
    if (highPriority.length > 0) {
      sections.push(this.generateTaskSection('High Priority', highPriority, 1));
    }

    // Medium priority tasks
    const mediumPriority = this.filterByPriority(report.clones, 'medium');
    if (mediumPriority.length > 0) {
      sections.push(this.generateTaskSection('Medium Priority', mediumPriority, highPriority.length + 1));
    }

    // Low priority tasks
    const lowPriority = this.filterByPriority(report.clones, 'low');
    if (lowPriority.length > 0) {
      sections.push(this.generateTaskSection('Low Priority', lowPriority, highPriority.length + mediumPriority.length + 1));
    }

    // Footer with instructions
    sections.push(this.generateFooter());

    return sections.join('\n\n');
  }

  /**
   * Writes the generated prompt to file
   */
  public writePrompt(report: AIReport): void {
    const markdown = this.generatePrompt(report);
    console.log('[Prompt Generator] Writing AI prompt to:', this.options.outputPath);
    writeFileSync(this.options.outputPath, markdown, 'utf-8');
  }

  private generateHeader(report: AIReport): string {
    const projectName = this.options.projectName || 'Code';
    const language = this.options.language || 'code';

    return `# ${projectName} - Code Duplication Refactoring Guide

> **Generated on:** ${new Date(report.generatedAt).toLocaleDateString()}
> **Language:** ${language}
> **AI Model:** ${report.ollamaModel || 'N/A'}

This document contains code duplication analysis and refactoring suggestions generated by jscpd-ai.
Each section includes duplicate code locations, AI analysis, and actionable refactoring tasks.`;
  }

  private generateSummary(report: AIReport): string {
    const { summary, refactoringSummary } = report;

    return `## ðŸ“Š Summary

- **Total Duplications Found:** ${summary.totalClones}
- **Files Affected:** ${summary.totalFiles}
- **Duplication Percentage:** ${summary.duplicatePercentage.toFixed(2)}%
- **AI Analyzed:** ${summary.aiAnalyzedClones} clones

### Refactoring Priority Breakdown

${refactoringSummary ? `
- ðŸ”´ **High Priority:** ${refactoringSummary.highPriority} (extract-function, extract-class)
- ðŸŸ¡ **Medium Priority:** ${refactoringSummary.mediumPriority} (create-module)
- ðŸŸ¢ **Low Priority:** ${refactoringSummary.lowPriority} (other improvements)
` : '_AI refactoring analysis not available._'}

---`;
  }

  private generateTaskSection(priority: string, clones: AIEnhancedClone[], startIndex: number): string {
    const emoji = priority === 'High Priority' ? 'ðŸ”´' : priority === 'Medium Priority' ? 'ðŸŸ¡' : 'ðŸŸ¢';
    const lines: string[] = [];

    lines.push(`## ${emoji} ${priority} Refactorings`);
    lines.push('');

    clones.forEach((clone, index) => {
      const taskNumber = startIndex + index;
      lines.push(this.generateTaskItem(clone, taskNumber));
      lines.push('');
    });

    return lines.join('\n');
  }

  private generateTaskItem(clone: AIEnhancedClone, taskNumber: number): string {
    const lines: string[] = [];

    // Task header with checkbox
    const refactoringType = clone.refactoringSuggestion?.type || 'refactor';
    lines.push(`### [ ] Task #${taskNumber}: ${this.formatRefactoringType(refactoringType)}`);
    lines.push('');

    // Location information
    if (clone.duplicationA && clone.duplicationB) {
      lines.push(`**ðŸ“ Locations:**`);
      lines.push(`- \`${clone.duplicationA.sourceId}:${clone.duplicationA.start?.line || '?'}-${clone.duplicationA.end?.line || '?'}\``);
      lines.push(`- \`${clone.duplicationB.sourceId}:${clone.duplicationB.start?.line || '?'}-${clone.duplicationB.end?.line || '?'}\``);
      lines.push('');

      const linesCount = (clone.duplicationA.end?.line || 0) - (clone.duplicationA.start?.line || 0);
      lines.push(`**ðŸ“ Size:** ${linesCount} lines duplicated`);
      lines.push('');
    }

    // AI Analysis
    if (clone.semanticAnalysis) {
      lines.push(`**ðŸ¤– AI Analysis:**`);
      lines.push(`- Similarity Score: ${clone.semanticAnalysis.similarityScore}%`);
      lines.push(`- Functionally Equivalent: ${clone.semanticAnalysis.functionallyEquivalent ? 'Yes' : 'No'}`);
      if (clone.semanticAnalysis.reasoning) {
        lines.push(`- Reasoning: ${clone.semanticAnalysis.reasoning}`);
      }
      lines.push('');
    }

    // Refactoring Suggestion
    if (clone.refactoringSuggestion) {
      lines.push(`**âœ¨ Refactoring Strategy:**`);
      lines.push(`- Type: ${clone.refactoringSuggestion.type}`);
      lines.push(`- Confidence: ${(clone.refactoringSuggestion.confidence * 100).toFixed(0)}%`);
      if (clone.refactoringSuggestion.description) {
        lines.push(`- Description: ${clone.refactoringSuggestion.description}`);
      }
      if (clone.refactoringSuggestion.reasoning) {
        lines.push(`- Reasoning: ${clone.refactoringSuggestion.reasoning}`);
      }
      lines.push('');
    }

    // Code snippets
    if (clone.duplicationA?.fragment) {
      lines.push(`**ðŸ“ Duplicated Code (Location A):**`);
      lines.push('```' + (clone.format || 'text'));
      lines.push(this.truncateCode(clone.duplicationA.fragment));
      lines.push('```');
      lines.push('');
    }

    if (clone.duplicationB?.fragment) {
      lines.push(`**ðŸ“ Duplicated Code (Location B):**`);
      lines.push('```' + (clone.format || 'text'));
      lines.push(this.truncateCode(clone.duplicationB.fragment));
      lines.push('```');
      lines.push('');
    }

    lines.push('---');

    return lines.join('\n');
  }

  private generateFooter(): string {
    return `## ðŸš€ Instructions for AI Coding Assistant

When refactoring these duplications:

1. **Analyze Context:** Review each duplication in the context of the entire file
2. **Extract Common Logic:** Create shared functions/classes/modules as suggested
3. **Maintain Behavior:** Ensure refactored code behaves identically to original
4. **Add Tests:** Write unit tests for extracted code if not already covered
5. **Update Imports:** Adjust import statements after extraction
6. **Clean Up:** Remove the duplicate code after extraction
7. **Document:** Add JSDoc/comments explaining the refactored code

### Recommended Approach

Work through tasks in order of priority:
- Start with ðŸ”´ High Priority (biggest impact)
- Then ðŸŸ¡ Medium Priority (moderate impact)
- Finally ðŸŸ¢ Low Priority (minor improvements)

Check off tasks as you complete them using \`[x]\` in the checkbox.

---

*Generated by jscpd-ai - AI-powered code duplication detection*`;
  }

  private filterByPriority(clones: AIEnhancedClone[], priority: 'high' | 'medium' | 'low'): AIEnhancedClone[] {
    return clones.filter(clone => {
      if (!clone.refactoringSuggestion) return false;

      const type = clone.refactoringSuggestion.type;

      if (priority === 'high') {
        return type === 'extract-function' || type === 'extract-class';
      } else if (priority === 'medium') {
        return type === 'create-module';
      } else {
        return type !== 'extract-function' && type !== 'extract-class' && type !== 'create-module';
      }
    });
  }

  private formatRefactoringType(type: string): string {
    return type
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  private truncateCode(code: string, maxLines: number = 50): string {
    const lines = code.split('\n');
    if (lines.length <= maxLines) {
      return code;
    }

    const truncated = lines.slice(0, maxLines).join('\n');
    return `${truncated}\n... (${lines.length - maxLines} more lines)`;
  }
}
